****************
* Circuit Tracer
* CS 221-002
* 29 April 2022
* Digno JR Teogalbo
**************** 

OVERVIEW:

 Create a path between two components on a circuit board.


INCLUDED FILES:

 * BoardsPanel.java - source file
 * Cell.java - source file
 * CircuitBoard.java - source file
 * CircuitTracer.java - source file
 * CircuitTracerGUI.java - source file
 * GridPanel.java - source file
 * InvalidFileFormatException.java - source file
 * MenuBar.java - source file
 * OccupiedPositionException.java - source file
 * Storage.java - source file
 * TraceState.java - source file
 * README - this file


COMPILING AND RUNNING:

 From the directory containing all source files, compile the
 driver class (and all dependencies) with the command:
 $ javac *.java

 Run the compiled class file with the command:
 $ java CircuitTracer

 Console output will give the results after the program finishes.

 Program usage:
    Usage: java CircuitTracer [-s | -q] [-c | -g] filename
    ======================================================
    Generate traces for circuit boards
    ======================================================
    -s
        Use stack for storage
    -q
        Use queue for storage
    -c
        Display output to console
    -g
        Display output to GUI


PROGRAM DESIGN AND IMPORTANT CONCEPTS:

 The CircuitBoard class is the object for which the circuit tracer
 program bases all operations on. The CircuitBoard constructor 
 creates a 2D char array with a width of columns and a height of 
 rows as defined in the file that it reads. For invalid files, we 
 throw an InvalidFileFormatException from which we display to console 
 or GUI. 
 
 From CircuitBoard char array, we use TraceState to store a list of 
 points with column and row indexes as the x and y values respectively. 
 TraceStates that are completed are added to bestPaths, with the newest 
 smallest path clearing and overwriting existing bestPaths and worse 
 ones ignored. The searching algorithm used is depth-first search (in 
 the case of stack as the Storage) or breadth-first search (in the case 
 of queue as the Storage). 
 
 The GUI wraps the CircuitTracer program and displays the content 
 generated by the program. We pass in the CircuitTracer program into 
 the CircuitTracerGUI as a parameter and from there we generate JPanel 
 components which display the boards and found solutions. The 
 CircuitTracerGUI program consists of a split pane which contains the 
 GridPanel and the BoardsPanel, and a MenuBar which allows the user to 
 save one or all the solutions to a file.

TESTING:

 Testing of the CircuitBoard constructor was done with the 
 CircuitTracerTester provided. Further of the CircuitBoard constructor 
 was done by manually testing and tweaking the program through various 
 edge cases, and verifying that the program results matched expected 
 results from normal operation. On invalid inputs, the program does not 
 crash and handles the exceptions according to the requirements. There 
 are no bugs in the console operation of the program, but there are a 
 few bugs with the GUI operation. Specifically with the GridPanel not 
 properly updating after button press or switching boards.

ANALYSIS:
 
 * How does the choice of Storage configuration (stack vs queue) affect 
 the sequence in which paths are explored in the search algorithm? (This 
 requires more than a "stacks are LIFOs and queues are FIFOs" answer.)

 With a stack, the sequence in which paths are explored will be similar 
 to a depth-first search algorithm. That is, we will traverse deeper (or 
 in one direction) before backtracking and searching in another direction. 
 Whereas with a queue, we will explore the path in a breadth-first search 
 algorithm. This will cause us to explore further in all directions 
 simultaneously at every step of the search.

 * Is the total number of search states (possible paths) affected by the 
 choice of stack or queue?

 No, the total number of search states is not affected by the choice of a 
 stack or a queue.

 * Is using one of the storage structures likely to find a solution in 
 fewer steps than the other? Always?

 On average, using a stack will find a solution quicker than a queue. 
 Except for when the solution is closer to our starting point, then a queue 
 may be faster.

 * Does using either of the storage structures guarantee that the first 
 solution found will be a shortest path?

 Yes, using a queue will guarantee that the first solution found is a 
 shortest path.

 * How is memory use (the maximum number of states in Storage at one time)
 affected by the choice of underlying structure?

 For a stack, the maximum number of states in Storage will be at most the 
 size of the grid array. Where as a stack may store many more states in 
 storage.

 * What is the Big-Oh runtime order for the search algorithm? Does it 
 reflect the maximum size of Storage? Does it reflect the number of board 
 posisions? Does it reflect the number of paths explored? Does it reflect 
 the maximum path length? Is it something else? What is 'n'? What is the 
 primary input factor that increases the difficulty of the task?

 The Big-Oh runtime order for the search algorithm will be O(n*m), where 
 n is the number of rows and m is the number of columns. This is because 
 we perform push/pop or queue/dequeue operations which have an O(1) 
 runtime, and we will search every available cell of the grid which means 
 we will perform O(n*m) operations. If the Storage type is a stack, then 
 the runtime order reflects the maximum size of Storage. The runtime 
 order does reflect the number of board positions because we search every 
 board position. It somewhat represents the maximum path length because 
 the maximum path length can theoretically be the size of the grid. If we 
 organize the grid as a tree, with the children of the nodes being 
 accessible cells, then the Big-Oh runtime order represents the number of 
 nodes and connections in this tree. The primary input factor that increases 
 the difficulty of the task is the size of the grid.

DISCUSSION:
 
 Before starting the project, I went through the given source files and 
 created a mental model of how each file interacted with each other. I 
 initially started with the CircuitBoard constructor and as I started I 
 found a lot of resemblance to the Grid Monitor project. From there I was 
 able to look back and reference my old code and reimplement it for this 
 project. I am thankful that I was able to write code that I still 
 understood as that made the whole process easier. Creating the CircuitTracer 
 was easy to do after knowing the CircuitBoard worked as intended. The overall 
 searching algorithm was provided to me from the assignment page as pseudocode, 
 and therefore implementing it was very straight-forward. I did additional 
 steps such as adding the board and bestPaths as instance variables in order 
 to use them for the CircuitTracerGUI.
 
EXTRA CREDIT:

 I attempted to implement the GUI for the CircuitTracer program. The GUI
 allows you to see the original board and all the found solutions. As well
 as export these boards to a text file.

----------------------------------------------------------------------------